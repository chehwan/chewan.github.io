import struct
import os

# ==========================================
# 1. 사용자 설정
# ==========================================
USER_SETTINGS = {
    "ORIGINAL_1S": r"C:/Users/munch/DeskTop/KARTRIDER_CODING/KARTRIDER/KartRider_5136/DataRaw_5136/kart_/saber5/model.1s",
    "KTM_FOLDER": r"C:/Users/munch/DeskTop/kartrider_model_1s_to_obj-main/total/",
    "OUTPUT_1S": r"C:/Users/munch/DeskTop/kartrider_model_1s_to_obj-main/total/saber_MODIFIED_v42_SafetyCheck.1s"
}

# ==========================================
# 2. 유틸리티
# ==========================================
def read_int32(f):
    return int.from_bytes(f.read(4), 'little')

def parse_ktm_and_build_1s_blob(ktm_path):
    # [v41 Logic - Unchanged]
    if not os.path.exists(ktm_path): return None
    
    with open(ktm_path, 'rb') as f:
        v_count = read_int32(f); v_data = f.read(v_count * 12)
        n_count = read_int32(f); n_data = f.read(n_count * 12)
        uv_count = read_int32(f)
        new_uv_data = bytearray()
        for _ in range(uv_count):
            idx1 = f.read(2); idx2 = f.read(2)
            u = f.read(4); v = f.read(4)
            new_uv_data.extend(u); new_uv_data.extend(v)
            new_uv_data.extend(idx1); new_uv_data.extend(idx2)
        f_count = read_int32(f); f_data = f.read(f_count * 20)

    f_count_packed = struct.pack('<I', f_count)
    blob = bytearray()
    blob.extend(b'\xAA\x27\x00\x00')
    blob.extend(struct.pack('<I', v_count)); blob.extend(v_data)
    blob.extend(struct.pack('<I', n_count)); blob.extend(n_data)
    blob.extend(struct.pack('<I', uv_count))
    
    if uv_count > 0:
        blob.extend(b'\x00\x00\x00\x00')
        new_uv_data[-4:] = f_count_packed
        blob.extend(new_uv_data)
    else:
        blob.extend(f_count_packed)
        
    blob.extend(f_data)
    return blob

# [1] Pre-Gap 복구 (매트릭스 ~ 메쉬 헤더)
def copy_pre_mesh_gap(f_in, f_out):
    # [v41 Logic - Unchanged]
    buffer = bytearray()
    start_pos = f_in.tell()
    while True:
        b = f_in.read(1)
        if not b: break
        if b == b'\xAA':
            nb = f_in.read(1)
            if nb == b'\x27':
                f_in.seek(-2, 1)
                f_out.write(buffer)
                print(f"    [Gap 1] Pre-Mesh Gap 복구: {len(buffer)} bytes")
                return True
            else:
                buffer.extend(b); buffer.extend(nb)
        else:
            buffer.extend(b)
    f_in.seek(start_pos)
    return False

# 원본 메쉬 끝 위치 계산 (Skip Logic 활용)
def get_original_mesh_end_pos(f_in):
    # [v41 Logic - Unchanged]
    start_pos = f_in.tell()
    if f_in.read(2) != b'\xAA\x27':
        f_in.seek(start_pos)
        return start_pos
    
    f_in.read(2) # Pad
    c = read_int32(f_in); f_in.seek(c*12, 1) # V
    c = read_int32(f_in); f_in.seek(c*12, 1) # N
    c = read_int32(f_in); f_in.read(4); f_in.seek(c*12, 1) # UV
    
    # Face
    f_in.seek(-4, 1); fc = read_int32(f_in); f_in.seek(0, 1)
    f_in.seek(fc * 20, 1)
    
    end_pos = f_in.tell()
    f_in.seek(start_pos)
    return end_pos

# [3] 특정 노드 위치 찾기 (Handle, Port, Fire 등)
# 기존 find_handle_pos를 확장하여 재활용
def find_node_pos(f_in, node_name):
    f_in.seek(0)
    d = f_in.read()
    idx = d.find(node_name.encode('utf-16le'))
    if idx != -1:
        # Child Count 위치 = Node String - 16 bytes
        return idx - 16
    return None

def main():
    orig_path = USER_SETTINGS["ORIGINAL_1S"]
    out_path = USER_SETTINGS["OUTPUT_1S"]
    ktm_folder = USER_SETTINGS["KTM_FOLDER"]

    if not os.path.exists(orig_path): return
    print(f"처리 시작: {orig_path}")

    with open(orig_path, 'rb') as f_in, open(out_path, 'wb') as f_out:
        # --- HEAD ---
        f_out.write(f_in.read(16))
        
        # Seat Header & Name
        h = f_in.read(12); f_out.write(h)
        nl = int.from_bytes(h[8:12], 'little')
        nb = f_in.read(nl*2); f_out.write(nb)
        nm = nb.decode('utf-16le').rstrip('\x00')
        print(f"[Root] {nm}")
        
        # Seat Matrix
        f_out.write(f_in.read(138))
        
        # --- BODY & GAPS ---
        ktm_path = os.path.join(ktm_folder, f"{nm}.ktm")
        new_mesh = parse_ktm_and_build_1s_blob(ktm_path)
        
        # [Added Check] 필요한 노드의 위치를 미리 확인 (Port/Fire 노드 검증)
        handle_pos = find_node_pos(f_in, "handle")
        port0_pos = find_node_pos(f_in, "port0")
        fire0_pos = find_node_pos(f_in, "fire0")
        print(f"    [Node Check] Handle: {handle_pos} | Port0: {port0_pos} | Fire0: {fire0_pos}")
        
        if new_mesh:
            # 1. Pre-Gap 복구
            copy_pre_mesh_gap(f_in, f_out)
            
            # 2. KTM 주입
            print(f"  -> KTM 교체")
            f_out.write(new_mesh)
            
            # 3. Post-Gap 복구 (핵심!)
            mesh_start = f_in.tell()
            mesh_end = get_original_mesh_end_pos(f_in)
            
            if handle_pos and handle_pos > mesh_end:
                # Gap Size = Handle 시작점 - 원본 메쉬 끝점
                post_gap_size = handle_pos - mesh_end
                
                # 원본에서 Post-Gap 읽기
                f_in.seek(mesh_end)
                post_gap_data = f_in.read(post_gap_size)
                
                # 새 파일에 쓰기
                f_out.write(post_gap_data)
                print(f"    [Gap 2] Post-Mesh Gap 복구: {len(post_gap_data)} bytes")
                
                # 파일 포인터를 Handle 시작점으로 이동
                f_in.seek(handle_pos)
            else:
                # [Error] Gap 계산 실패 시, 안전하게 Handle 노드의 시작점으로 이동
                print("    [Warning] Post-Gap을 계산할 수 없습니다. Handle 위치로 복사 재개.")
                if handle_pos:
                     f_in.seek(handle_pos)
                else:
                     f_in.seek(mesh_end) # 최후의 수단
                
            # 4. Tail 복사 (Handle ~ End)
            # 이 f_in.read()가 Handle, Port0/1, Fire0/1을 모두 원본 그대로 복사합니다.
            print("  -> 하위 구조 (Port/Fire 포함) 원본 100% 복사")
            f_out.write(f_in.read())
            
        else:
            f_out.write(f_in.read())

    print(f"\n[완료] {out_path}")

if __name__ == "__main__":
    main()